{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _contextSubscribe = require('../lib/contextSubscribe');\n\nvar _bem = require('../lib/bem');\n\nvar _state = require('../lib/state');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n} // we only use raf for a minor accessibility feature so it is possible to get away with this little \"polyfilling\"\n\n\nvar raf = typeof window !== 'undefined' && 'requestAnimationFrame' in window ? window.requestAnimationFrame : setTimeout;\nvar panelInstances = 0;\nvar panelUniqId = 0;\n/*\n * Handles prop integrity and manages the complexity of props vs. context vs. nothing at all\n * @param {object} props\n * @param {object} context\n * @param {string} uniqId\n */\n\nfunction getTabPanelProps(_ref, _ref2, uniqId) {\n  var bem = _ref2.bem,\n      tabbordion = _ref2.tabbordion;\n\n  var checkedProp = _ref.checked,\n      disabledProp = _ref.disabled,\n      idProp = _ref.id,\n      index = _ref.index,\n      modifiers = _ref.modifiers,\n      nameProp = _ref.name,\n      type = _ref.type,\n      value = _ref.value,\n      visibleProp = _ref.visible,\n      props = _objectWithoutProperties(_ref, ['checked', 'disabled', 'id', 'index', 'modifiers', 'name', 'type', 'value', 'visible']);\n\n  var _tabbordion$getState = tabbordion.getState(),\n      animateContent = _tabbordion$getState.animateContent,\n      checkedPanelsRaw = _tabbordion$getState.checkedPanels,\n      disabledPanelsRaw = _tabbordion$getState.disabledPanels,\n      firstVisiblePanel = _tabbordion$getState.firstVisiblePanel,\n      lastVisiblePanel = _tabbordion$getState.lastVisiblePanel,\n      panelName = _tabbordion$getState.panelName,\n      panelType = _tabbordion$getState.panelType,\n      tabbordionId = _tabbordion$getState.tabbordionId;\n\n  var checkedPanels = (0, _state.getArray)(checkedPanelsRaw);\n  var disabledPanels = (0, _state.getArray)(disabledPanelsRaw); // props have preference over what comes from context\n\n  var name = (nameProp != null ? nameProp : panelName) || tabbordionId || 'tabbordion-panel-' + uniqId;\n  var id = idProp || (tabbordionId || name) + '-' + index;\n  var checked = checkedProp != null ? checkedProp : checkedPanels.includes(index);\n  var disabled = disabledProp != null ? disabledProp : disabledPanels.includes(index);\n  var visible = visibleProp === false ? 'hidden' : firstVisiblePanel === index && 'first' || lastVisiblePanel === index && 'last' || 'between';\n  var contentId = null;\n  var hasContent = null;\n  var childPool = [props.children]; // sniff the id out or use our own (will be exposed via context)\n\n  while (!contentId && childPool.length) {\n    _react.Children.forEach(childPool.shift(), function (child) {\n      if (contentId || !child || !child.type) {\n        return;\n      }\n\n      var props = child.props || child._store && child._store.props || {};\n\n      if (child.type === _react2.default.Fragment) {\n        childPool.push(props.children);\n      } else if (child.type.hasContent) {\n        hasContent = true;\n        contentId = props.id || null;\n      }\n    });\n  }\n\n  if (!contentId) contentId = id + '-content';\n\n  var _bem$getState = bem.getState(),\n      bemModifiers = _bem$getState.bemModifiers,\n      bemSeparator = _bem$getState.bemSeparator,\n      blockElements = _bem$getState.blockElements;\n\n  return _extends({}, props, {\n    animateContent: animateContent,\n    bemModifiers: bemModifiers,\n    bemSeparator: bemSeparator,\n    blockElements: blockElements,\n    checked: checked,\n    disabled: disabled,\n    contentId: contentId,\n    hasContent: hasContent,\n    id: id,\n    index: index,\n    name: name,\n    type: type != null ? type : panelType,\n    value: value != null ? value : String(index),\n    visible: visible,\n    checkedPanels: checkedPanels,\n    disabledPanels: disabledPanels,\n    modifiers: bemModifiers ? (0, _state.getArray)(modifiers).concat([bemModifiers[checked ? 'checked' : 'unchecked'], bemModifiers[hasContent ? 'content' : 'noContent'], bemModifiers[disabled ? 'disabled' : 'enabled'], bemModifiers[visible]].concat(_toConsumableArray(firstVisiblePanel === lastVisiblePanel && index === firstVisiblePanel ? [bemModifiers['last']] : []))).concat(animateContent ? [bemModifiers.animated, animateContent] : []) : (0, _state.getArray)(modifiers),\n    onChangePanel: tabbordion.onChangePanel\n  });\n}\n\nvar TabPanel = function (_PureComponent) {\n  _inherits(TabPanel, _PureComponent);\n\n  function TabPanel(props, context) {\n    _classCallCheck(this, TabPanel); // essentially an attempt for keeping id and name consistent from page to page even when that data is missing\n\n\n    var _this = _possibleConstructorReturn(this, (TabPanel.__proto__ || Object.getPrototypeOf(TabPanel)).call(this, props, context));\n\n    panelInstances++; // fallback to generate name and id\n\n    _this.uniqId = '' + panelUniqId;\n    panelUniqId++; // use caching to minimize the need of recalculating stuff all the time\n\n    _this.cachedProps = getTabPanelProps(props, context, _this.uniqId);\n    _this.getInputRef = _this.getInputRef.bind(_this);\n    _this.onChange = _this.onChange.bind(_this);\n    _this.onClickLabel = _this.onClickLabel.bind(_this);\n    _this.subscribers = [];\n    _this.childContext = {\n      tabbordionPanel: {\n        getState: function getState() {\n          return {\n            animateContent: _this.cachedProps.animateContent,\n            checked: _this.cachedProps.checked,\n            contentId: _this.cachedProps.contentId,\n            disabled: _this.cachedProps.disabled,\n            inputId: _this.cachedProps.id,\n            index: _this.cachedProps.index,\n            modifiers: _this.cachedProps.modifiers,\n            visible: _this.cachedProps.visible\n          };\n        },\n        onClickLabel: _this.onClickLabel,\n        subscribe: (0, _contextSubscribe.addSubscriber)(_this.subscribers),\n        unsubscribe: (0, _contextSubscribe.removeSubscriber)(_this.subscribers)\n      }\n    };\n    _this.panelState = _this.childContext.tabbordionPanel.getState();\n    return _this;\n  }\n\n  _createClass(TabPanel, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.context.bem.subscribe(this);\n      this.context.tabbordion.subscribe(this);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps, nextContext) {\n      this.cachedProps = getTabPanelProps(nextProps, nextContext, this.uniqId);\n      var panelState = this.childContext.tabbordionPanel.getState();\n\n      if ((0, _state.isShallowlyDifferent)(panelState, this.panelState)) {\n        this.subscribers.forEach(function (component) {\n          return component.forceUpdate();\n        });\n        this.panelState = panelState;\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.context.bem.unsubscribe(this);\n      this.context.tabbordion.unsubscribe(this);\n      delete this.cachedProps;\n      panelInstances--;\n      if (panelInstances === 0) panelUniqId = 0;\n    }\n  }, {\n    key: 'getChildContext',\n    value: function getChildContext() {\n      return this.childContext;\n    }\n  }, {\n    key: 'getInputRef',\n    value: function getInputRef(input) {\n      this.input = input;\n    }\n    /** Handler for input checkbox or radio */\n\n  }, {\n    key: 'onChange',\n    value: function onChange(event) {\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      var _cachedProps = this.cachedProps,\n          index = _cachedProps.index,\n          onChangePanel = _cachedProps.onChangePanel;\n      if (onChangePanel) onChangePanel(index);\n    }\n    /** Handler for TabLabel child */\n\n  }, {\n    key: 'onClickLabel',\n    value: function onClickLabel() {\n      var _this2 = this;\n\n      var _cachedProps2 = this.cachedProps,\n          index = _cachedProps2.index,\n          onChangePanel = _cachedProps2.onChangePanel,\n          type = _cachedProps2.type;\n      if (onChangePanel) onChangePanel(index); // make sure focus goes to the input element, that is what sane browsers do when a label is clicked\n\n      raf(function () {\n        // of course things may go wrong so make sure all expected conditions are met before doing stuff\n        if (_this2.input && (_this2.input.checked || type === 'checkbox') && document.activeElement !== _this2.input) {\n          _this2.input.focus();\n        }\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _cachedProps3 = this.cachedProps,\n          animateContent = _cachedProps3.animateContent,\n          bemModifiers = _cachedProps3.bemModifiers,\n          bemSeparator = _cachedProps3.bemSeparator,\n          blockElements = _cachedProps3.blockElements,\n          checked = _cachedProps3.checked,\n          checkedPanels = _cachedProps3.checkedPanels,\n          children = _cachedProps3.children,\n          className = _cachedProps3.className,\n          Component = _cachedProps3.component,\n          contentId = _cachedProps3.contentId,\n          disabled = _cachedProps3.disabled,\n          disabledPanels = _cachedProps3.disabledPanels,\n          hasContent = _cachedProps3.hasContent,\n          id = _cachedProps3.id,\n          index = _cachedProps3.index,\n          modifiers = _cachedProps3.modifiers,\n          onChangePanel = _cachedProps3.onChangePanel,\n          name = _cachedProps3.name,\n          style = _cachedProps3.style,\n          type = _cachedProps3.type,\n          value = _cachedProps3.value,\n          visible = _cachedProps3.visible,\n          props = _objectWithoutProperties(_cachedProps3, ['animateContent', 'bemModifiers', 'bemSeparator', 'blockElements', 'checked', 'checkedPanels', 'children', 'className', 'component', 'contentId', 'disabled', 'disabledPanels', 'hasContent', 'id', 'index', 'modifiers', 'onChangePanel', 'name', 'style', 'type', 'value', 'visible']);\n\n      var panelBem = (0, _bem.bemClassName)(blockElements, 'panel', modifiers, bemSeparator);\n      var ariaSelected = checked ? 'true' : 'false';\n      return _react2.default.createElement(Component, _extends({}, props, {\n        'aria-expanded': hasContent && ariaSelected,\n        'aria-selected': ariaSelected,\n        className: !panelBem ? className : className ? panelBem + ' ' + className : panelBem,\n        role: 'tab',\n        style: _extends({}, style, {\n          display: visible === 'hidden' ? 'none' : null\n        })\n      }), _react2.default.createElement('input', {\n        'aria-controls': contentId,\n        checked: checked,\n        'data-state': 'tabbordion',\n        disabled: disabled || visible === 'hidden',\n        id: id,\n        name: name,\n        onChange: this.onChange,\n        ref: this.getInputRef,\n        type: type,\n        value: value\n      }), children);\n    }\n  }]);\n\n  return TabPanel;\n}(_react.PureComponent);\n\nTabPanel.childContextTypes = {\n  tabbordionPanel: _propTypes2.default.object\n};\nTabPanel.contextTypes = {\n  bem: _propTypes2.default.object,\n  tabbordion: _propTypes2.default.object\n};\nTabPanel.defaultProps = {\n  component: 'li'\n};\nTabPanel.propTypes = {\n  // state (these will override contextTypes if set)\n  checked: _propTypes2.default.bool,\n  className: _propTypes2.default.string,\n  disabled: _propTypes2.default.bool,\n  id: _propTypes2.default.string,\n  index: _propTypes2.default.number,\n  name: _propTypes2.default.string,\n  type: _propTypes2.default.oneOf(['checkbox', 'radio']),\n  value: _propTypes2.default.string,\n  visible: _propTypes2.default.bool,\n  // contents\n  children: _propTypes2.default.node,\n  component: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object, _propTypes2.default.string]),\n  // BEM convention props\n  modifiers: _propTypes2.default.array\n};\nexports.default = TabPanel;","map":null,"metadata":{},"sourceType":"script"}